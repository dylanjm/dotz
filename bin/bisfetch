#!/usr/bin/env bash

readonly PROGNAME="$(basename "${0}")"
readonly ARGS=("${@}")

NORMAL='\033[0m'
BOLD='\033[1m'
RED='\033[1;31m'
GREEN='\033[1;32m'
BLUE='\033[1;34m'
MAGENTA='\033[1;4;35m'
YELLOW='\033[1;33m'

dry_run=0
lookback=1
folder=""
BISON=${BISON_DIR:-$HOME/Documents/projects/bison}

yellow() { echo "${YELLOW}$*${NORMAL}"; }
green() { echo "${GREEN}$*${NORMAL}"; }
blue() { echo "${BLUE}$*${NORMAL}"; }
red() { echo "${RED}$*${NORMAL}"; }
magenta() { echo "${MAGENTA}$*${NORMAL}"; }
bold() { echo "${BOLD}$*${NORMAL}"; }

foldernames() {
    (
        printf "IFA_677 RE_Ginna_Rodlets LOCA_ORNL_cladding_burst_tests IFA_519\n"
        printf "OSIRIS_H09 Riso_II5 IFA_535 IFA_636\n"
        printf "RIA_NSRR_FK IFA_432 LOCA_IFA_650 LOCA_MT4_MT6A\n"
        printf "Riso_II3 Calvert_Cliffs-1_PROTOTYPE IFA_534 LOCA_Hardy_cladding_test\n"
        printf "IFA_562 LOCA_REBEKA_cladding_burst_tests HBEP OSIRIS_J12\n"
        printf "LOCA_PUZRY_cladding_burst_tests	FUMEXII_Regate Riso_AN3 IFA_515_RodA1\n"
        printf "Riso_GEm_STR013 Riso_GE7_ZX115 Riso_AN4 IFA_431\n"
        printf "LOCA_ANL_cladding_burst_tests RIA_CABRI_REP_Na4 HbepR1 RIA_CABRI_REP_Na\n"
        printf "Tribulation LOCA_cladding_creep_tests IFA_597_3 US_PWR_16_x_16\n"
        printf "Riso_AN8 Riso_AN2 Super_Ramp\n"
    ) |
        column -t
}

usage() {
    cat <<-EOF
        $(echo -e "$(red "
         ______  _________ _______  _______  _______ _________ _______
        (  ___ \ \__   __/(  ____ \(  ____ \(  ____ )\__   __/(  ____ \|\     /|
        | (   ) )   ) (   | (    \/| (    \/| (    \/   ) (   | (    \/| )   ( |
        | (__/ /    | |   | (_____ | (__    | (__       | |   | |      | (___) |
        |  __ (     | |   (_____  )|  __)   |  __)      | |   | |      |  ___  |
        | (  \ \    | |         ) || (      | (         | |   | |      | (   ) |
        | )___) )___) (___/\____) || )      | (____/\   | |   | (____/\| )   ( |
        |/ \___/ \_______/\_______)|/       (_______/   )_(   (_______/|/     \|
        ")")

        $(echo -e "$(blue "BIS")")on $(echo -e "$(blue "F")")etch:

        Script that fetches most recent nightly run data from HPC.

        $(echo -e "$(yellow "USAGE")"):
               $PROGNAME [-h] [-n] [-l num] [-f folder] [<folder> ...]

        $(echo -e "$(yellow "OPTIONS")"):
               -h        - Show this message
               -n        - Perform a dry-run
               -l        - Look back a previous run; Defaults to 1 (most-recent)
               -f        - Folder of interest; the flag is optional but a folder is required."

        $(echo -e "$(yellow "ARGS")"):
               <folder>        - Folder of interest from remote machine. To fetch all folders specify '*'

        $(echo -e "$(green "Possible folder names include")"):
        $(foldernames)
    EOF
    exit 0
}

get_args() {
    while getopts ":hnl:f:" flag; do
        case "$flag" in
        n)
            dry_run=1
            ;;
        l)
            lookback=${OPTARG}
            ;;
        h)
            usage
            ;;
        f)
            folder="${OPTARG}"
            ;;
        :)
            echo "Invalid options: $OPTARG requires an argurment" 1>&2
            exit 1
            ;;
        \?)
            echo "Usage: bisfetch [-h] [-n] [-l num] [-f folder] [folder(s) ...]"
            exit 1
            ;;
        esac
    done

    shift $((OPTIND - 1))

    # Check to ensure folder is specified
    if [ -z "$folder" ] && [ -z "$1" ]; then
        printf "%b\n\n" "$(red "You must specify a folder of interest"):"
        foldernames
        exit 1
    fi

    # If no -f flag then assign folder to first ARG
    [ -n "$1" ] && folder="$1"
}

fetch_folder_files() {
    # Find all *_out.csv files on Falcon1 for specific folder
    # This is some bash-fu, but bassically we want to find the most recently
    # modified folder of the type 'bison_XXXXXXXX'
    # We then want to find all the *_out.csv files inside the folder specified at the
    # command-line within the 'bison_XXXXXXXX' folder.
    ssh falcon1 -qn 'newest=$(find /projects/bison/git/* -mindepth 0 -maxdepth 0 -type d -regex ".*/bison_[0-9]+" -printf "%T@\t%f\n" | ' \
        'sort -t\t -r -nk1,5 | ' \
        'sed -n '"$lookback"'p | ' \
        'cut -f2-); ' \
        'find /projects/bison/git/$newest/assessment/LWR/validation/'"$folder"'/* -type f -name "*_out.csv" -perm 660 -not -path "*/doc/*" -printf "%p\n" 2>/dev/null'
}

create_local_paths() {
    # Modify remote paths to fit for local paths
    for i in "${files[@]}"; do
        echo "$i" |
            sed -E "s|/projects/bison/git/bison_[0-9]{8}|$BISON|g"
    done
}

check_remote_files() {
    # If ssh returned no results then error out.
    if [[ -z "${files[0]}" ]]; then
        printf "%b\n\n" "$(red "ERROR: Folder '$folder' Not Found!")"
        printf "%b\n\n" "$(green "NOTE"): Try using the lookback flag (-l) to fetch a previous nightly run."
        printf "%b\n" "$(yellow Possible Folder Names Include):"
        foldernames
        exit 1
    else
        printf "\n\tüìÅ %b:\n" \
            "$(bold "Inspecting Nightly Folder") $(magenta "${files[0]:20:14}") $(bold "for Assessment") $(magenta "$folder")"
    fi
}

copy_files() {
    for ((i = 0; i < ${#files[@]}; i++)); do
        if [[ $dry_run == 0 ]]; then
            printf "\t‚ï≠‚îÄ %b %s\n" "$(blue "Remote =>")" "${files[i]}"
            printf "\t‚îú‚îÄ %b %s\n" "$(yellow "Local  =>")" "${local_paths[i]}"
            printf "\t‚ï∞‚îÄ Fetching Remote File...\r"

            if scp -qp falcon1:"${files[i]}" "${local_paths[i]}" 2>/dev/null; then
                printf "\t%b\n\n" "‚ï∞‚îÄ Fetching Remote File‚Ä¶ $(green "Successful!")"
            else
                printf "\t%b\n\n" "‚ï∞‚îÄ Fetching Remote File‚Ä¶ $(red "Error!")"
            fi
        else
            printf "\t‚ï≠‚îÄ %b %s\n" "$(blue "Remote =>")" "${files[i]}"
            printf "\t‚ï∞‚îÄ %b %s\n\n" "$(yellow "Local  =>")" "${local_paths[i]}"
        fi
    done
}

main() {
    getargs "${@}"
    mapfile -t files < <(fetch_folder_files)
    mapfile -t local_paths < <(create_local_paths "${files[*]}")
    check_remote_files
    copy_files
}

main "${ARGS[@]}"
